{"version":3,"sources":["../src/result_transformer.js"],"names":["ResultFormat","transformDataToTable","analyticsResult","options","datapoints","_","map","rows","row","target","resultTarget","transformDataToTimeSeries","groupBys","data","groupBy","results","length","groupings","metricLabel","push","Object","keys","key","series","orderBy","result","transform","response","config","resultFormat","TABLE","TIME_SERIES"],"mappings":";;;;;;;;AAAQA,kB,sBAAAA,Y;;;AAEFC,0B,GAAuB,SAAvBA,oBAAuB,CAACC,eAAD,EAAkBC,OAAlB,EAA8B;AACzD,YAAIC,aAAaC,EAAEC,GAAF,CAAMJ,gBAAgBK,IAAtB,EAA4B,eAAO;AAClD,iBAAO,CAACC,IAAI,CAAJ,CAAD,EAASA,IAAI,CAAJ,CAAT,CAAP,CADkD,CACzB;AAC1B,SAFgB,CAAjB;;AAIA,eAAO;AACLC,kBAAQN,QAAQO,YADX;AAELN,sBAAYA;AAFP,SAAP;AAID,O;;AAEKO,+B,GAA4B,SAA5BA,yBAA4B,CAACT,eAAD,EAAkBC,OAAlB,EAA8B;AAC9D,YAAMS,WAAWT,QAAQU,IAAR,CAAaC,OAA9B;AACA,YAAMC,UAAU,EAAhB;AACA,YAAIH,SAASI,MAAT,GAAkB,CAAtB,EAAyB;AACvB,cAAIC,YAAY,EAAhB;AACAZ,YAAEC,GAAF,CAAMJ,gBAAgBK,IAAtB,EAA4B,eAAO;AACjC,gBAAMW,cAAcV,IAAI,CAAJ,CAApB;AACA,gBAAI,CAACS,UAAUC,WAAV,CAAL,EAA6B;AAC3BD,wBAAUC,WAAV,IAAyB,EAAzB;AACD;AACDD,sBAAUC,WAAV,EAAuBC,IAAvB,CAA4B,CAACX,IAAI,CAAJ,CAAD,EAASA,IAAI,CAAJ,CAAT,CAA5B,EALiC,CAKc;AAChD,WAND;AAOAY,iBAAOC,IAAP,CAAYJ,SAAZ,EAAuBX,GAAvB,CAA2B,eAAO;AAChC,gBAAMF,aAAaa,UAAUK,GAAV,CAAnB;AACA,gBAAMC,SAAS;AACbd,sBAAQa,GADK;AAEblB,0BAAYC,EAAEmB,OAAF,CAAUpB,UAAV,EAAsB,CAAC,CAAD,CAAtB,EAA2B,KAA3B;AAFC,aAAf;AAIAW,oBAAQI,IAAR,CAAaI,MAAb;AACD,WAPD;AAQD,SAjBD,MAiBO;AACL,cAAIE,SAAUxB,qBAAqBC,eAArB,EAAsCC,OAAtC,CAAd;AACAsB,iBAAOrB,UAAP,GAAoBC,EAAEmB,OAAF,CAAUC,OAAOrB,UAAjB,EAA6B,CAAC,CAAD,CAA7B,EAAkC,KAAlC,CAApB;AACAW,kBAAQI,IAAR,CAAaM,MAAb;AACD;AACD,eAAOV,OAAP;AACD,O;;2BAEYW,S,GAAY,SAAZA,SAAY,CAACC,QAAD,EAAWxB,OAAX,EAAuB;AAC9C,YAAMD,kBAAkByB,SAASd,IAAT,CAAcA,IAAd,CAAmBY,MAA3C;AACA,YAAMG,SAASD,SAASC,MAAxB;AACA,YAAIA,OAAOC,YAAP,KAAwB7B,aAAa8B,KAAzC,EAAgD;AAC9C,iBAAO,CAAC7B,qBAAqBC,eAArB,EAAsC0B,MAAtC,CAAD,CAAP;AACD,SAFD,MAEO,IAAIA,OAAOC,YAAP,KAAwB7B,aAAa+B,WAAzC,EAAsD;AAC3D,iBAAOpB,0BAA0BT,eAA1B,EAA2C0B,MAA3C,CAAP;AACD;AACF,O","file":"result_transformer.js","sourcesContent":["import {ResultFormat} from './types/resultFormat';\n\nconst transformDataToTable = (analyticsResult, options) => {\n  let datapoints = _.map(analyticsResult.rows, row => {\n    return [row[1], row[0]]; // value, timestamp\n  });\n\n  return {\n    target: options.resultTarget,\n    datapoints: datapoints\n  }\n}\n\nconst transformDataToTimeSeries = (analyticsResult, options) => {\n  const groupBys = options.data.groupBy;\n  const results = [];\n  if (groupBys.length > 0) {\n    let groupings = {};\n    _.map(analyticsResult.rows, row => {\n      const metricLabel = row[1];\n      if (!groupings[metricLabel]) {\n        groupings[metricLabel] = [];\n      }\n      groupings[metricLabel].push([row[2], row[0]]); // value, timestamp\n    });\n    Object.keys(groupings).map(key => {\n      const datapoints = groupings[key];\n      const series = {\n        target: key,\n        datapoints: _.orderBy(datapoints, [1], 'asc')\n      }\n      results.push(series);\n    });\n  } else {\n    let result =  transformDataToTable(analyticsResult, options);\n    result.datapoints = _.orderBy(result.datapoints, [1], 'asc');\n    results.push(result);\n  }\n  return results;\n}\n\nexport const transform = (response, options) => {\n  const analyticsResult = response.data.data.result;\n  const config = response.config;\n  if (config.resultFormat === ResultFormat.TABLE) {\n    return [transformDataToTable(analyticsResult, config)];\n  } else if (config.resultFormat === ResultFormat.TIME_SERIES) {\n    return transformDataToTimeSeries(analyticsResult, config);\n  }\n}\n"]}