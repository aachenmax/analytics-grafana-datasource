{"version":3,"sources":["../../src/result_transformer.js"],"names":["transformDataToTable","analyticsResult","options","datapoints","_","map","rows","row","target","resultTarget","transformDataToTimeSeries","groupBys","data","groupBy","results","length","groupings","metricLabel","push","Object","keys","key","series","orderBy","result","transform","response","config","resultFormat","ResultFormat","TABLE","TIME_SERIES"],"mappings":";;;;;;;AAAA;;AAEA,IAAMA,uBAAuB,SAAvBA,oBAAuB,CAACC,eAAD,EAAkBC,OAAlB,EAA8B;AACzD,MAAIC,aAAaC,EAAEC,GAAF,CAAMJ,gBAAgBK,IAAtB,EAA4B,eAAO;AAClD,WAAO,CAACC,IAAI,CAAJ,CAAD,EAASA,IAAI,CAAJ,CAAT,CAAP,CADkD,CACzB;AAC1B,GAFgB,CAAjB;;AAIA,SAAO;AACLC,YAAQN,QAAQO,YADX;AAELN,gBAAYA;AAFP,GAAP;AAID,CATD;;AAWA,IAAMO,4BAA4B,SAA5BA,yBAA4B,CAACT,eAAD,EAAkBC,OAAlB,EAA8B;AAC9D,MAAMS,WAAWT,QAAQU,IAAR,CAAaC,OAA9B;AACA,MAAMC,UAAU,EAAhB;AACA,MAAIH,SAASI,MAAT,GAAkB,CAAtB,EAAyB;AACvB,QAAIC,YAAY,EAAhB;AACAZ,MAAEC,GAAF,CAAMJ,gBAAgBK,IAAtB,EAA4B,eAAO;AACjC,UAAMW,cAAcV,IAAI,CAAJ,CAApB;AACA,UAAI,CAACS,UAAUC,WAAV,CAAL,EAA6B;AAC3BD,kBAAUC,WAAV,IAAyB,EAAzB;AACD;AACDD,gBAAUC,WAAV,EAAuBC,IAAvB,CAA4B,CAACX,IAAI,CAAJ,CAAD,EAASA,IAAI,CAAJ,CAAT,CAA5B,EALiC,CAKc;AAChD,KAND;AAOAY,WAAOC,IAAP,CAAYJ,SAAZ,EAAuBX,GAAvB,CAA2B,eAAO;AAChC,UAAMF,aAAaa,UAAUK,GAAV,CAAnB;AACA,UAAMC,SAAS;AACbd,gBAAQa,GADK;AAEblB,oBAAYC,EAAEmB,OAAF,CAAUpB,UAAV,EAAsB,CAAC,CAAD,CAAtB,EAA2B,KAA3B;AAFC,OAAf;AAIAW,cAAQI,IAAR,CAAaI,MAAb;AACD,KAPD;AAQD,GAjBD,MAiBO;AACL,QAAIE,SAAUxB,qBAAqBC,eAArB,EAAsCC,OAAtC,CAAd;AACAsB,WAAOrB,UAAP,GAAoBC,EAAEmB,OAAF,CAAUC,OAAOrB,UAAjB,EAA6B,CAAC,CAAD,CAA7B,EAAkC,KAAlC,CAApB;AACAW,YAAQI,IAAR,CAAaM,MAAb;AACD;AACD,SAAOV,OAAP;AACD,CA1BD;;AA4BO,IAAMW,gCAAY,SAAZA,SAAY,CAACC,QAAD,EAAWxB,OAAX,EAAuB;AAC9C,MAAMD,kBAAkByB,SAASd,IAAT,CAAcA,IAAd,CAAmBY,MAA3C;AACA,MAAMG,SAASD,SAASC,MAAxB;AACA,MAAIA,OAAOC,YAAP,KAAwBC,2BAAaC,KAAzC,EAAgD;AAC9C,WAAO,CAAC9B,qBAAqBC,eAArB,EAAsC0B,MAAtC,CAAD,CAAP;AACD,GAFD,MAEO,IAAIA,OAAOC,YAAP,KAAwBC,2BAAaE,WAAzC,EAAsD;AAC3D,WAAOrB,0BAA0BT,eAA1B,EAA2C0B,MAA3C,CAAP;AACD;AACF,CARM","file":"result_transformer.js","sourcesContent":["import {ResultFormat} from './types/resultFormat';\n\nconst transformDataToTable = (analyticsResult, options) => {\n  let datapoints = _.map(analyticsResult.rows, row => {\n    return [row[1], row[0]]; // value, timestamp\n  });\n\n  return {\n    target: options.resultTarget,\n    datapoints: datapoints\n  }\n}\n\nconst transformDataToTimeSeries = (analyticsResult, options) => {\n  const groupBys = options.data.groupBy;\n  const results = [];\n  if (groupBys.length > 0) {\n    let groupings = {};\n    _.map(analyticsResult.rows, row => {\n      const metricLabel = row[1];\n      if (!groupings[metricLabel]) {\n        groupings[metricLabel] = [];\n      }\n      groupings[metricLabel].push([row[2], row[0]]); // value, timestamp\n    });\n    Object.keys(groupings).map(key => {\n      const datapoints = groupings[key];\n      const series = {\n        target: key,\n        datapoints: _.orderBy(datapoints, [1], 'asc')\n      }\n      results.push(series);\n    });\n  } else {\n    let result =  transformDataToTable(analyticsResult, options);\n    result.datapoints = _.orderBy(result.datapoints, [1], 'asc');\n    results.push(result);\n  }\n  return results;\n}\n\nexport const transform = (response, options) => {\n  const analyticsResult = response.data.data.result;\n  const config = response.config;\n  if (config.resultFormat === ResultFormat.TABLE) {\n    return [transformDataToTable(analyticsResult, config)];\n  } else if (config.resultFormat === ResultFormat.TIME_SERIES) {\n    return transformDataToTimeSeries(analyticsResult, config);\n  }\n}\n"]}